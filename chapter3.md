# 第三章 传输层

* 理解传输层服务的基本理论和基本机制
  * 多路复用/分用
  * 可靠数据传输机制
  * 流量控制机制
  * 拥塞控制机制
* 掌握Internet的传输层协议
  * UDP：无连接传输服务
  * TCP：面向连接的传输服务
  * TCP拥塞控制

## 传输层服务概述

### 传输层服务和协议

* 传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制
* 端系统运行传输层协议
  * 发送方：将应用递交的消息分成一个或多个的segment，并向下传给网络层
  * 接收方：将接收到的segment组装成消息并向上交给应用层
* 传输层可以为应用层提供多种协议
  * Internet上的TCP
  * Internet上的UDP

### 传输层 VS 网络层

* 网络层：提供主机之间的逻辑通信机制
* 传输层：提供应用进程之间的逻辑通信机制
  * 位于网络层之上
  * 依赖于网络层服务
  * 对网络层服务进行(可能的)增强

### Internet传输层协议

* 可靠、按序的交付服务(TCP)
  * 拥塞控制
  * 流量控制
  * 连接建立
* 不可靠的交付服务(UDP)
  * 基于“尽力而为”的网络层，没有做(可靠性方面的)扩展
* 两种服务均不保证
  * 延迟
  * 带宽

### 多路复用和多路分用

* 如果某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用

接收端进行多路分用

* 传输层依据头部信息将收到的segment交给正确的socket，即不同进程

发送端进行多路复用

* 从多个socket接收数据，为每块数据封装上头部信息，生成segment，交给网络层

### 分用如何工作

* 主机接收到IP数据报(datagram)
  * 每个数据报携带源IP地址、目的IP地址
  * 每个数据报携带一个传输层的段(segment)
  * 每个段携带源端口号和目的端口号
* 主机收到segment之后，传输层协议提取IP地址和端口号信息，将segment导向相应的socket
  * TCP做更多处理

### 无连接分用

* 利用端口号创建socket
* UDP的socket用二元组标识
  * (目的IP地址， 目的端口号)
* 主机收到UDP段后
  * 检查段中的目的端口号
  * 将UDP段导向绑定在该端口号的socket
* 来自不同源IP地址和/或源端口号的IP数据包被导向同一个socket

### 面向连接的分用

* TCP的socket用四元组标识
  * 源IP地址
  * 源端口号
  * 目的IP地址
  * 目的端口号
* 接收端利用所有的四个值将segment导向合适的socket
* 服务器可能同时支持多个TCP socket
  * 每个socket用自己的四元组标识
* web服务器为每个客户端开不同的socket

## UDP

### UDP: user datagram protocol

* 基于Internet IP协议
  * 复用/分用
  * 简单的错误校验
* "Best effort" 服务，UDP段可能
  * 丢失
  * 非按序到达
* 无连接
  * UDP发送方和接收方之间不需要握手
  * 每个UDP段的处理独立于其他段
* 常用于流媒体应用
  * 容忍丢失
  * 速率敏感
* UDP还用于
  * DNS
  * SNMP
* 在UDP上实现可靠数据传输？
  * 在应用层增加可靠性机制
  * 应用特定的错误恢复机制

UDP为什么存在？

* 无需建立连接(减少延迟)
* 实现简单：无需维护连接状态
* 头部开销少
* 没有拥塞控制：应用可以更好的控制发送时间和速率

### UDP校验和

* 目的：检测UDP段在传输中是否发生错误(如位翻转)
* 发送方
  * 将段的内容视为16-bit整数
  * 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和
  * 发送方将校验和放入校验和字段
* 接收方
  * 计算所收到段的校验和
  * 将其与校验和字段进行对比
    * 不相等：检测出错误
    * 相等：没有检测出错误(但可能有错误)

## 可靠数据传输原理

* 什么是可靠
  * 不错、不丢、不乱
* 可靠数据传输协议
  * 可靠数据传输对应用层、传输层、链路层都很重要
  * 网络Top-10问题
  * 信道的不可靠特性决定了可靠数据传输协议的复杂性

### 可靠数据传输协议

* 渐进地设计可靠数据传输协议的发送方和接收方
* 只考虑单向数据传输
  * 但控制信息双向流动
* 利用状态机刻画传输协议

### Rdt 1.0：可靠信道上的可靠数据传输

* 底层信道完全可靠
  * 不会发生错误
  * 不会丢失分组
* 发送方和接收方的FSM独立

## Rdt 2.0

### Rdt 2.0：产生位错误的信道

* 底层信道可能翻转分组中的位(bit)
  * 利用校验和检测位错误
* 如何从错误中恢复？
  * 确认机制(ACK):接收方显式地告知发送方分组已正确接收
  * NAK:接收方显式地告知发送方分组有错误
  * 发送方收到NAK后，重传分组
* 基于这种重传机制的rdt协议称为ARQ协议
* Rdt 2.0中引入的新机制
  * 差错检测
  * 接收方反馈控制消息：ACK/NAK
  * 重传

## Rdt 2.1和2.2

### Rdt 2.0有什么缺陷？

* 如果ACK/NAK消息发生错误/被破坏会怎么样？
  * 为ACK/NAK增加校验和，检错并纠错
  * 发送方收到被破坏ACK/NAK时不知道接收方发生了什么，添加额外的控制消息
  * 如果ACK/NAK坏掉，发送方重传
  * 不能简单的重传：产生重复分组
* 如何解决重复分组问题？
  * 序列号：发送方给每个分组增加序列号
  * 接收方丢弃重复分组

### Rdt 2.1 VS Rdt 2.0

* 发送方：
  * 为每个分组增加了序列号
  * 两个序列号(0, 1)就够用，为什么？
  * 需校验ACK/NAK消息是否发生错误
  * 状态数量翻倍
    * 状态必须“记住”“当前”的分组序列号
* 接收方：
  * 需判断分组是否是重复
    * 当前所处状态提供了期望收到分组的序列号
  * 注意：接收方无法知道ACK/NAK是否被发送方正确收到

### Rdt 2.2：无NAK消息协议

* 我们真的需要两种确认消息(ACK + NAK)吗？
* 与rdt 2.1功能相同，但是只使用ACK
* 如何实现？
  * 接收方通过ACK告知最后一个被正确接收的分组
  * 在ACK消息中显示地加入被确认分组的序列号
* 发送方收到重复ACK之后，采取与收到NAK消息相同的动作
  * 重传当前分组

## Rdt 3.0

* 如果信道既可能发生错误，也可能丢失分组，怎么办？
  * “校验和+序列号+ACK+重传”够用吗？
* 方法：发送方等待“合理”时间
  * 如果没收到ACK，重传
  * 如果分组或ACK只是延迟而不是丢了
    * 重传会产生重复，序列号机制能够处理
    * 接收方需在ACK中显式告知所确认的分组
  * 需要定时器

### Rdt 3.0性能分析

* Rdt 3.0能够正确工作，但性能很差
* 网络协议限制了物理资源的利用

## 流水线机制与滑动窗口协议

### 流水线机制：提高资源利用率

### 流水线协议

* 允许发送方在收到ACK之前连续发送多个分组
  * 更大的序列号范围
  * 发送方和/或接收方需要更大的存储空间以缓存分组

### 滑动窗口协议

* 滑动窗口协议：sliding-window protocol
* 窗口
  * 允许使用的序列号范围
  * 窗口尺寸为N：最多有N个等待确认的消息
* 滑动窗口
  * 随着协议的运行，窗口在序列号空间内向前滑动
* 滑动窗口协议：GBN，SR

## Go-Back-N协议

### GBN协议：发送方

* 分组头部包含k-bit序列号
* 窗口尺寸为N，最多允许N个分组未确认
* ACK(n):确认到序列号n(包含n)的分组均已被正确接收
  * 可能收到重复ACK
* 为空中的分组设置计时器
* 超时Timeout(n)事件：重传序列号大于等于n，还未收到ACK的所有分组

### GBN：接收方扩展FSM

* ACK机制：发送拥有最高序列号的、已被正确接收的分组的ACK
  * 可能产生重复ACK
  * 只需要记住唯一的expectedseqnum
* 乱序到达的分组：
  * 直接丢弃->接收方没有缓存
  * 重新确认序列号最大的、按序到达的分组

## Selective Repeat协议

* GBN协议有什么缺陷？
* 接收方对每个分组单独进行确认
  * 设置缓存机制，缓存乱序到达的分组
* 发送方只重传那些没收到ACK的分组
  * 为每个分组设定时器
* 发送方窗口
  * N个连续的序列号
  * 限制已发送且未确认的分组

## TCP概述

* 点对点
  * 一个发送方，一个接收方
* 可靠的、按序的字节流
* 流水线机制
  * TCP拥塞控制和流量控制机制设置窗口尺寸
* 发送方/接收方缓存
* 全双工
  * 同一连接中能够传输双向数据流
* 面向连接
  * 通信双方在发送数据之前必须建立连接
  * 连接状态只在连接的两端中维护，在沿途节点中并不维护状态
  * TCP连接包括：两台主机上的缓存、连接状态变量、socket等
* 流量控制机制

### TCP：序列号和ACK

* 序列号：
  * 序列号指的是segment中第一个字节的编号，而不是segment的编号
  * 建立TCP连接时，双方随机选择序列号
* ACKs：
  * 希望接收到的下一个字节的序列号
  * 累计确认：该序列号之前的所有字节均已被正确收到
* 接收方如何处理乱序到达的segment？
  * TCP规范中没有规定，由TCP的实现者做出决策

## TCP可靠数据传输

* TCP在IP层提供的不可靠服务基础上实现可靠数据传输服务
* 流水线机制
* 累计确认
* TCP使用单一重传定时器
* 触发重传的事件
  * 超时
  * 收到重复ACK

### TCP RTT和超时

* 问题：如何设置定时器的超时时间？
* 大于RTT
  * 但是RTT是变化的
* 过短：
  * 不必要的重传
* 过长：
  * 对段丢失时间反应慢
* 问题：如何估计RTT？
* SampleRTT：测量从段发出去到收到ACK的时间
  * 忽略重传
* SampleRTT变化
  * 测量多个SampleRTT，求平均值，形成RTT的估计值EstimatedRTT
* 定时器超时时间的设置：
  * EstimatedRTT+“安全边界”
  * EstimatedRTT变化大->较大的边界
* 测量RTT的变化值：SampleRTT与EstimatedRTT的差值
  * DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT| (typically, β = 0.25)
* 定时器超时时间的设置：
  * TimeoutInterval = EstimatedRTT + 4 * DevRTT

### TCP 发送方事件

* 从应用层收到数据
  * 创建segment
  * 序列号是segment第一个字节的编号
  * 开启计时器
  * 设置超时时间：TimeoutInterval
* 超时
  * 重传引起超时的segment
  * 重启定时器
* 收到ACK
  * 如果确认此前未确认的segment
    * 更新sendbase
    * 如果窗口中还有未被确认的分组，重新启动定时器

### 快速重传机制

* TCP的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大
  * 重发丢失的分组之前要等待很长时间
* 通过重复ACK检测分组丢失
  * sender会背靠背发送多个分组
  * 如果某个分组丢失，可能会引发多个重复的ACK
* 如果sender收到对同一数据的3个ACK，则假定该数据之后的段已经丢失
  * 快速重传：在定时器超时之前即进行重传

## TCP流量控制

### TCP流量控制

* 接收方为TCP连接分配buffer
* 上层应用可能处理buffer中数据的速度较慢
* 发送方不会传输的太多太快以至于淹没接收方(buffer溢出)
* 速度匹配机制
* (假定TCP receiver丢弃乱序的segments)
* receiver通过在segment的头部字段将rcvwindow告诉sender
* sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲rcvwindow尺寸
* receiver告知sender rcvwindow=0，会出现什么情况

### TCP连接管理

* TCP sender和receiver在传输数据前需要建立连接
* 初始化TCP变量
  * seq.#
  * buffer和流量控制信息
* client：连接的发起者
* server：等待客户连接请求

  Three way handshake：
    Step 1: client host sends TCP SYN segment to server
      * specifies inital seq #
      * no data
    Step 2: server host receivers SYN, replies with SYNACK segment
      * server allocates buffers
      * specifies server initial seq.#
    Step 3: client receivers SYNACK, replies with ACK segment, which may contain data

### TCP连接管理：关闭

closing a connextion:

step 1: client向server发送TCP FIN控制segment
step 2: server收到FIN，回复ACK。关闭连接，发送FIN
step 3: client收到FIN，回复ACK。进入“等待”——如果收到FIN，会重新发送ACK
step 4: server收到ACK。关闭连接。

## 拥塞控制原理

### 拥塞控制

* 非正式定义：“太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理”
* 表现：
  * 分组丢失(路由器缓存溢出)
  * 分组延迟过大(在路由器排队缓存中排队)
  * 拥塞控制 VS 流量控制
  * A top-10 problem.

### 拥塞的成因和代价

* 两个senders，两个receivers
* 一个路由器，无限缓存
* 没有重传
* 拥塞时分组延迟太大
* 达到最大throughput
* 一个路由器，有限buffers
* sender重传分组

* 拥塞的代价
  * 对给定的"goodput"，要做更多的工作(重传)
  * 造成资源的浪费
  * 当分组被drop时，任何用于该分组的“上游”传输能力全部被浪费掉

### 拥塞控制的方法

* 端到端拥塞控制
  * 网络层不需要显式的提供支持
  * 端系统通过观察loss，delay等网络行为判断是否发生拥塞
  * TCP采取这种方法
* 网络辅助的拥塞控制
  * 路由器像发送方显式地反馈网络拥塞信息
  * 简单的拥塞指示(1bit): SNA, DECbit,TCP/IP ECN, ATM
  * 指示发送方应该采取何种速率

### ATM ABR拥塞控制

* ABR：available bit rate
  * “弹性服务”
  * 如果发送方路径“underloaded”
    * 使用可用带宽
  * 如果发送方路径拥塞
    * 将发送速率降低到最低保障速率
* RM(resource management) cells
  * 发送方发送
  * 交换机设置RM cell位(网络辅助)
    * NI bit：rate不许增长
    * CI bit：拥塞指示
  * RM cell由接收方返回给发送方
* 在RM cell中有显式的速率(ER)字段：两个字节
  * 拥塞的交换机可以将ER置为更低的值
  * 发送方获知路径所能支持的最小速率
* 数据cell中的EFCI位：拥塞的交换机将其设为1
  * 如果RM cell前面的data cell的EFCI位被设为1，那么发送方在返回的RM cell中置CI位

## TCP拥塞控制

### TCP拥塞控制的基本原理

* sender限制发送速率
  * LastByteSent - LastByteAcked <= CongWin
  * rate = CongWin / RTT (Bytes/sec)
* CongWin:
  * 动态调整以改变发送速率
  * 反映所感知到的网络拥塞
* 如何感知网络拥塞
  * Loss事件 = timeout或3个重复ACK
  * 发生loss事件后，发送方降低速率
* 如何合理地调整发送速率
  * 加性增——乘性减：AIMD
  * 慢启动：SS

### 加性增——乘性减：AIMD

* 原理：逐渐增加发送速率，谨慎探测可用带宽，直到发生loss
* 方法：AIMD
  * Additive Increase:每个RTT将congwin增大一个MSS——拥塞避免
  * Multiplicative Decrease:发生loss后将CongWin减半

### TCP慢启动：SS

* TCP连接建立时，CongWin=1
  * 初始速率=20kbps
* 可用带宽可能远远高于初始速率：
  * 希望快速增长
* 原理：
  * 当连接开始时，指数性增长
* 指数性增长
  * 每个RTT将CongWin翻倍
  * 收到每个ACK进行操作
* 初始速率很慢，但是快速攀升
* 何时应该指数性增长切换为线性增长(拥塞避免)
  * 当CongWin达到Loss事件前值的1/2时。
  * 实现方法：
    * 变量 Threshold
    * Loss事件发生时，Threshold被设为Loss事件前CongWin值的1/2.

### Loss事件的处理

* 三个重复ACKs：
  * CongWin切到一半
  * 然后线性增长
* Timeout事件：
  * CongWin直接设为一个MSS
  * 然后指数增长
  * 达到threshold后，再线性增长
* Philosophy：
  * 三个重复ACKs表示网络还能够传输一些segments
  * timeout事件表明拥塞更为严重

### TCP拥塞控制：总结

* 当拥塞窗口大小低于Threshold时，发送方处于慢启动状态，此时拥塞窗口应指数性增长。
* 当拥塞窗口大大低于Threshold时，发送方处于拥塞避免状态，此时窗口应线性增长。
* 当收到三个重复的ACK时，Threshold应当减为原来的一半，拥塞窗口设置为Threshold.
* 当timeout事件发生，Threshold应当减为原来的一半，拥塞窗口减为1.

## TCP性能分析

### TCP吞吐率

* 给定拥塞窗口大小和RTT，TCP的平均吞吐率是多少？
  * 忽略掉Slow start
* 假定发生超时时CongWin的大小为W，吞吐率是W/RTT
* 超时后，CongWin=W/2，吞吐率是W/2 RTT
* 平均吞吐率为：0.75W/RTT

### 未来的TCP

* 吞吐率与丢包率的关系
  * CongWin从W/2增加至W时出现第一个丢包，那么一共发送的分组数为W/2+(W/2+1)+(W/2+2)+……+W=3W^2/8 + 3W/4
  * W很大时，3W^2/8 >> 3W/4,因此L = 8/(3W^2)
* L=2*10^-10
* 高速网络下需要设计新的TCP

### TCP的公平性

* 公平性？
  * 如果K个TCP Session共享相同的瓶颈带宽R，那么每个session的平均速率为R/K
  * TCP是公平的
* 公平性与UDP
  * 多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率
  * 使用UDP：以恒定速率发送，能够容忍丢失
  * 产生了不公平
* 研究：TCP friendly
* 公平性与并发TCP连接
  * 某些应用会打开多个并发连接
  * Web浏览器
  * 产生公平性问题

## 网络层

### 网络层

* 从发送主机向接收主机传送数据段
* 发送主机：将数据段封装到数据报中
* 接收主机：向传输层交付数据段
* 每个主机和路由器都运行网络层协议
* 路由器检验所有穿越它的IP数据报的头部域
  * 决策如何处理IP数据报

### 网络层核心功能——转发与路由

* 转发：将分组从路由器的输入端口转移到合适的输出端口
  * 转发表确定在本路由器如何转发分组
* 路由：确定分组从源到目的经过的路径
  * 路由算法

### 网络层核心功能——连接建立

* 某些网络的重要功能：
  * ATM，帧中继， X.25
* 数据分组传输之前两端主机需要首先建立虚拟/逻辑连接
  * 网络设备(如路由器)参与连接的建立
* 网络层连接与传输层连接的对比：
  * 网络层连接：两个主机之间(路径上的路由器等网络设备参与其中)
  * 传输层连接：两个应用进程之间(对中间网络设备透明)

### 网络层服务模型

* 无连接服务
  * 不事先为系列分组的传输确定传输路径
  * 每个分组独立确定传输路径
  * 不同分组可能传输路径不同
  * 数据报网络
* 连接服务
  * 首先为系列分组的传输确定从源到目的经过的路径(建立连接)
  * 然后沿该路径(连接)传输系列分组
  * 系列分组传输路径相同
  * 传输结束后拆除连接
  * 虚电路网络

## 虚电路网络

### 连接服务与无连接服务

* 数据报网络与虚电路网络是典型两类分组交换网络
* 数据报网络提供网络层无连接服务
* 虚电路网络提供网络层连接服务
* 类似于传输层的无连接服务(UDP)和面向连接服务(TCP)，但是网络层服务：
  * 主机到主机服务
  * 网络核心实现

### 虚电路

* 虚电路：一条从源主机到目的主机，类似于电路的路径(逻辑连接)
  * 分组交换
  * 每个分组的传输利用链路的全部带宽
  * 源到目的路径经过的网络层设备共同完成虚电路功能
* 通信过程：
  * 呼叫建立->数据传输->拆除呼叫
* 每个分组携带虚电路标识(VCID)，而不是目的主机地址
* 虚电路经过的每个网络设备(如路由器)，维护每条经过它的虚电路连接状态
* 链路、网络设备资源(如带宽、缓存等)可以面向VC进行预分配
  * 预分配资源 = 可预期服务性能
  * 如ATM的电路仿真

### VC的具体实现

* 每条虚电路包括：
  * 从源到目的主机的一条路径
  * 虚电路号(VCID)，沿路每段链路一个编号
  * 沿路每个网络层设备(如路由器)，利用转发表记录经过的每条虚电路
* 沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址
* 同一条VC，在每段链路上的VCID通常不同
  * 路由器转发分组时依据转发表改写/替换虚电路号
* VC路径上每个路由器都需要维护VC连接的状态信息

### 虚电路信令协议

* 用于VC的建立、维护与拆除
  * 路径选择
* 应用于虚电路网络
  * 如ATM、帧中继网络等
* 目前的Internet不采用

## 数据报网络

### 数据报网络

* 网络层无连接
* 每个分组携带目的地址
* 路由器根据分组的目的地址转发分组
  * 基于路由协议/算法构建转发表
  * 检索转发表
  * 每个分组独立选路

### 数据报转发表

* 路由算法(协议)确定通过网络的端到端路径
* 转发表确定在本路由器如何转发分组

### 最长前缀匹配优先

* 在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口

### 数据报网络 or VC网络

* Internet(数据报网络)
  * 计算机之间的数据交换
    * “弹性”服务，没有严格时间需求
  * 链路类型众多
    * 特点、性能各异
    * 统一服务困难
  * “智能”端系统(计算机)
    * 可以自适应、性能控制、差错恢复
  * 简化网络，复杂“边缘”
* ATM(VC网络)
  * 电话网络演化而来
  * 核心业务是实时对话：
    * 严格的时间、可靠性需求
    * 需要有保障的服务
  * “哑”端系统(非智能)
    * 电话机
    * 传真机
  * 简化“边缘”，复杂网络

## IP协议——IP数据报

### Internet网络层

* 主机、路由器网络层主要功能
  * 路由协议
    * 路径选择
    * RIP、OSPF、BGP
  * IP协议
    * 寻址规约
    * 数据报(分组)格式
    * 分组处理规约
  * ICMP协议
    * 差错报告
    * 路由器“信令”

### IP数据报(分组)格式

* 版本号字段占4位：IP协议的版本号
  * 4 -> IPv4, 6 -> IPv6
* 首部长度字段占4位：IP分组首部长度
  * 以4字节为单位
  * 5 -> IP首部长度为20(5 * 4)字节
* 服务类型(TOS)字段占8位：指示期望获得哪种类型的服务
  * 1998年这个字段改名为区分服务
  * 只有在网络提供区分服务时使用
  * 一般情况下不使用，通常IP分组的该字段(第2字节)的值为00H
* 总长度字段占16位：IP分组的总字节数(首部+数据)
  * 最大IP分组的总长度：65535B
  * 最小的IP分组首部：20B
  * IP分组可以封装的最大数据：65535-20=65515B
* 生存时间字段占8位：IP分组在网络中可以通过的路由器数(或跳步数)
  * 路由器转发一次分组，TTL减1
  * 如果TTL=0，路由器则丢弃该IP分组
* 协议字段占8位：指示IP分组封装的是哪个协议的数据包
  * 实现复用/分解
  * 6 -> TCP，表示封装的为TCP段；17 -> UDP，表示封装的是UDP数据报
* 首部校验和字段占16位：实现对IP分组首部的差错检测
  * 计算校验和时，该字段置全0
  * 采用反码算数运算求和，和的反码作为首部校验和字段
  * 逐跳计算、逐跳校验
* 源IP地址、目的IP地址字段各占32位：分别标识发送分组的源主机/路由器(网络接口)和接收分组的目的主机/路由器(网络接口)的IP地址
* 选项字段占长度可变，范围在1~40B之间：携带安全、源选路径、时间戳和路由记录等内容
  * 实际上很少被使用
* 填充字段占长度可变，范围在0~3B之间：目的是补齐整个首部，符合32位对齐。即保证首部长度是4字节的倍数

## IP协议——IP分片

### 最大传输单元(MTU)

* 网络链路存在MTU(最大传输单元)——链路层数据帧可封装数据的上限
  * 不同链路的MTU不同

### IP分片与重组

* 大IP分组向较小MTU链路转发时，可以被“分片”
  * 1个IP分组分为多片IP分组
  * IP分片到达目的主机后进行“重组”
* IP首部的相关字段用于标识分片以及确定分片的相对顺序

### IP分组格式

* 标识字段占16位：标识一个IP分组
  * IP协议利用一个计数器，每产生IP分组计数器加1，作为该IP分组的标识
* 标志位字段占3位：(保留， DF， MF)
  * DF，禁止分片
  * MF，更多分片
  * DF=1：禁止分片;DF=0，允许分片
  * MF=1：非最后一片;MF=0：最后一片(或未分片)
* 片偏移字段占13位：一个IP分组分片封装原IP分组数据的相对偏移量
  * 片偏移字段以8字节为单位

### IP分片过程

* 假设原IP分组总长度为L，待转发链路的MTU为M
* 若L>M，且DF=0，则可以/需要分片
* 分片时每个分片的标识复制原IP分组的标识
* 通常分片时，除最后一个分片，其他分片均分为MTU允许的最大分片
* 一个最大分片可封装的数据应该是8的倍数，因此，一个最大分片可封装的数据为：d=floor((M - 20) / 8) * 8
* 需要的总片数为：n = ceil((L - 20) / d)
* 每片的片偏移字段取值为：Fi = (d / 8) * (i - 1), (1 <= i <= n)
* 每片的总长度字段为：除最后一片都是d+20，最后一片是L-(n-1)d
* 每片的MF标志位为：除最后一片外全部取1
